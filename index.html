<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>TTTIW - Table Tennis Tracker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@400;700;800&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <style>
        :root {
            --primary-orange: #ff8c00;
            --primary-orange-dark: #e67e00;
            --accent-orange: #ffa500;
            --dark-bg: #0a0a0a;
            --panel-bg: #151515;
            --text-light: #e8e8e8;
            --text-secondary: #999999;
            --border-color: #ff8c00;
            --border-color-accent: #1a1a1a;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--dark-bg);
            background-image: linear-gradient(135deg, #0a0a0a 0%, #1a0a00 100%);
            color: var(--text-light);
            margin: 0;
            padding: 15px;
            display: flex;
            justify-content: center;
        }

        @media (max-width: 768px) {
            body { padding: 10px; }
        }

        @media (max-width: 480px) {
            body { padding: 8px; }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); }
        ::-webkit-scrollbar-thumb { background: var(--primary-orange); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent-orange); }

        /* Firefox Scrollbar */
        * { scrollbar-color: var(--primary-orange) rgba(0, 0, 0, 0.3); scrollbar-width: thin; }

        .container {
            max-width: 1000px;
            width: 100%;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1024px) {
            .container { grid-template-columns: 1.5fr 1fr; gap: 15px; }
        }
        @media (max-width: 768px) { .container { grid-template-columns: 1fr; gap: 15px; } }
        @media (max-width: 480px) { .container { gap: 12px; } }

        header {
            grid-column: 1 / -1;
            text-align: center;
            padding: 25px 0;
            border-bottom: 3px solid var(--primary-orange);
            margin-bottom: 25px;
            background: linear-gradient(180deg, transparent 0%, rgba(255, 140, 0, 0.1) 100%);
        }

        h1 { margin: 0; color: var(--primary-orange); font-size: clamp(2rem, 8vw, 3rem); text-transform: uppercase; letter-spacing: 2px; font-weight: 800; text-shadow: 0 0 20px rgba(255,140,0,0.5); font-family: 'Oxanium', sans-serif; }
        h1 span { color: var(--accent-orange); font-weight: 700; }
        header p { color: var(--text-secondary); font-size: 0.95rem; letter-spacing: 2px; }

        .panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,140,0,0.1);
            border: 1px solid rgba(255, 140, 0, 0.2);
            border-left: 4px solid var(--primary-orange);
        }

        h2 {
            margin-top: 0;
            color: var(--primary-orange);
            border-bottom: 2px solid rgba(255,140,0,0.3);
            padding-bottom: 10px;
            font-size: clamp(0.95rem, 4vw, 1.1rem);
            letter-spacing: 0.5px;
            font-family: 'Oxanium', sans-serif;
            font-weight: 700;
        }

        table { width:100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border-color); font-size: clamp(0.8rem, 2.5vw, 0.95rem); }
        th { background-color: var(--primary-orange); color: #000; text-transform: uppercase; font-size: clamp(0.7rem, 2.5vw, 0.9rem); font-weight: 700; }
        tr:nth-child(even) { background-color: rgba(255,255,255,0.03); }
        tr:hover { background-color: rgba(255, 140, 0, 0.15); }

        .rank-1 { color: var(--primary-orange); font-weight: bold; font-size: 1.1rem; text-shadow: 0 0 8px rgba(255,140,0,0.4); }

        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: clamp(0.8rem, 3vw, 0.9rem); color: #aaa; }
        input, select { width:100%; padding:12px; border:1px solid rgba(255,140,0,0.3); background-color: rgba(20,20,20,0.8); color: var(--text-light); border-radius:6px; box-sizing:border-box; font-size: clamp(0.9rem,4vw,1rem); transition:all 0.3s ease; }
        input:focus, select:focus { outline:none; border-color: var(--primary-orange); box-shadow: 0 0 12px rgba(255,140,0,0.4); background-color: rgba(20,20,20,1); }
        button { width:100%; padding:12px; background-color: var(--primary-orange); color:#000; border:none; border-radius:6px; font-size: clamp(0.85rem,3vw,1rem); font-weight:bold; cursor:pointer; transition:all 0.2s ease; text-transform:uppercase; letter-spacing:1px; box-shadow: 0 4px 15px rgba(255,140,0,0.3); }
        button:hover { background-color: var(--accent-orange); box-shadow:0 6px 20px rgba(255,140,0,0.5); transform: translateY(-2px); }
        .vs { text-align:center; font-weight:bold; color:var(--primary-orange); margin:12px 0; font-size:clamp(0.95rem,3vw,1.1rem); letter-spacing:1px; }

        .action-buttons { display:flex; gap:5px; margin-top:5px; }
        .btn-small { flex:1; padding:8px 12px; font-size: clamp(0.7rem,2.5vw,0.8rem); cursor:pointer; border:1px solid var(--primary-orange); background-color: rgba(255,140,0,0.15); color: var(--primary-orange); border-radius:4px; transition:all 0.2s ease; font-weight:600; min-height:32px; display:flex; align-items:center; justify-content:center; }
        .btn-delete { background-color: rgba(255,50,50,0.2); color: #ff6464; }
        .btn-small:hover { background-color: var(--primary-orange); color:#000; box-shadow:0 0 10px rgba(255,140,0,0.4); }
        .rules-list { list-style:none; padding:0; margin:10px 0; }
        .rules-list li { padding:10px; margin:5px 0; background-color: rgba(255,140,0,0.1); border-left:3px solid var(--primary-orange); border-radius:4px; }

        .match-row { display:flex; justify-content:space-between; align-items:center; padding:10px; background-color: rgba(255,255,255,0.02); border:1px solid var(--border-color); border-radius:6px; margin:8px 0; gap:8px; flex-wrap:wrap; }
        @media (max-width:480px) { .match-row { flex-direction:column; align-items:flex-start; gap:6px; } }
        .match-info { flex-grow:1; min-width:0; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèì TTTIW</h1>
            <p>Table Tennis Texas InventionWorks</p>
        </header>

        <div class="panel">
            <h2>Top Players</h2>
            <table id="leaderboard">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Player</th>
                        <th>ELO</th>
                        <th>W - L</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body"></tbody>
            </table>
        </div>

        <div class="controls">
            <div class="panel">
                <h2>Log Match Result</h2>
                <form id="log-match-form">
                    <div class="form-group">
                        <label for="winner-select">Winner üèÜ</label>
                        <select id="winner-select" required>
                            <option value="">Select Winner...</option>
                        </select>
                    </div>
                    <div class="vs">VS</div>
                    <div class="form-group">
                        <label for="loser-select">Loser üíÄ</label>
                        <select id="loser-select" required>
                            <option value="">Select Loser...</option>
                        </select>
                    </div>
                    <button type="submit">Update Ratings</button>
                </form>
            </div>
        </div>

        <div class="panel" style="margin-bottom:20px;">
            <h2>Add Player</h2>
            <form id="add-player-form">
                <div class="form-group">
                    <label for="player-name">Name</label>
                    <input type="text" id="player-name" required placeholder="e.g. Ma Long">
                </div>
                <div class="form-group">
                    <label for="initial-elo">Starting ELO (Default 1500)</label>
                    <input type="number" id="initial-elo" value="1500" required>
                </div>
                <button type="submit">Register Player</button>
            </form>
        </div>

        <div class="panel">
            <h2>üë• Manage Players</h2>
            <div id="players-list" style="max-height:250px; overflow-y:auto;">
                <p style="color:#888; text-align:center;">No players yet</p>
            </div>
        </div>

        <div class="panel">
            <h2>üìã Action Log</h2>
            <div id="action-log-container" style="max-height:500px; overflow-y:auto;">
                <p style="color:#888; text-align:center;">No actions recorded yet</p>
            </div>
        </div>

        <div class="panel">
            <h2>‚öôÔ∏è Rules</h2>
            <ul class="rules-list">
                <li><strong>First to 11:</strong> Win by reaching 11 points with a 2-point lead</li>
                <li><strong>2 Serves Each:</strong> Players alternate with 2 serves per turn</li>
                <li><strong>Deuce Serving:</strong> At 10-10 (deuce), alternate serves on each point</li>
                <li><strong>Serve Height:</strong> Ball must be struck 6 inches above the table surface</li>
                <li><strong>No Reserves:</strong> Must have a confirmed player, no substitutions allowed</li>
                <li><strong>ELO Rating:</strong> Based on opponent strength and match outcome</li>
                <li><strong>K-Factor:</strong> 32 points per match (legacy/ELO)</li>
                <li><strong>Starting Rating:</strong> 1500 ELO by default</li>
                <li><strong>Fairness:</strong> Beating stronger players gains more ELO</li>
            </ul>
        </div>
    </div>

    <script>
        // ---------- Firebase Configuration ----------
        const firebaseConfig = {
            apiKey: "AIzaSyCHRQOLzC0DcuZv4aCqsL4EM_IVthiZSIc",
            authDomain: "tttiw-6d44e.firebaseapp.com",
            projectId: "tttiw-6d44e",
            storageBucket: "tttiw-6d44e.firebasestorage.app",
            messagingSenderId: "902138155809",
            appId: "1:902138155809:web:0860c66b77d07746952460"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // ---------- State ----------
        let players = [];
        let actionLog = [];

        // Glicko params & RD inactivity rules
        const Q = Math.log(10) / 400; // q constant for Glicko
        const MIN_RD = 50;            // best RD (active)
        const MAX_RD = 100;           // worst RD before hidden
        const RD_INCREASE_DAYS = 10;  // days to go from MIN_RD -> MAX_RD
        const K_FACTOR = 32;          // legacy Elo fallback (unused for Glicko updates)

        // DOM refs
        const leaderboardBody = document.getElementById('leaderboard-body');
        const addPlayerForm = document.getElementById('add-player-form');
        const logMatchForm = document.getElementById('log-match-form');
        const winnerSelect = document.getElementById('winner-select');
        const loserSelect = document.getElementById('loser-select');
        const actionLogContainer = document.getElementById('action-log-container');
        const playersListContainer = document.getElementById('players-list');

        // ---------- Initialization ----------
        async function init() {
            try {
                const playersSnapshot = await db.collection('players').get();
                players = playersSnapshot.docs.map(doc => doc.data());

                const actionLogSnapshot = await db.collection('actionLog').orderBy('timestamp', 'asc').get();
                actionLog = actionLogSnapshot.docs.map(doc => doc.data());

                // Ensure default fields exist for old entries
                players.forEach(p => {
                    if (typeof p.rd === 'undefined') p.rd = MAX_RD;
                    if (typeof p.volatility === 'undefined') p.volatility = 0.06;
                    if (typeof p.wins === 'undefined') p.wins = 0;
                    if (typeof p.losses === 'undefined') p.losses = 0;
                });

                updatePlayerRDs();
                updateUI();
            } catch (err) {
                console.error('Error loading data:', err);
                alert('Error connecting to database. Check your Firebase config.');
            }
        }

        // ---------- RD calculation (50 -> 100 over 10 days) ----------
        function calculateRD(lastMatchDate) {
            // If no last match recorded, treat as new/unplayed: MAX_RD (hidden)
            if (!lastMatchDate) return MAX_RD;

            const now = new Date();
            const last = new Date(lastMatchDate);
            const daysSinceMatch = Math.max(0, (now - last) / (1000 * 60 * 60 * 24));
            const rdIncrease = (daysSinceMatch / RD_INCREASE_DAYS) * (MAX_RD - MIN_RD);
            return Math.min(MAX_RD, MIN_RD + rdIncrease);
        }

        function updatePlayerRDs() {
            players.forEach(player => {
                player.rd = calculateRD(player.lastMatchDate);
            });
        }

        // ---------- Glicko (original) implementation ----------
        function g(rd) {
            // rd is in rating points
            return 1 / Math.sqrt(1 + (3 * Math.pow(Q, 2) * Math.pow(rd, 2)) / (Math.PI * Math.PI));
        }

        function E(rating, oppRating, oppRD) {
            const gg = g(oppRD);
            return 1 / (1 + Math.pow(10, -gg * (rating - oppRating) / 400));
        }

        /**
         * Calculate Glicko rating update for a single player across a set of results.
         * results: array of { opponentRating, opponentRD, score } where score is 1 (win), 0 (loss), or 0.5
         * Returns { rating, rd } (volatility not implemented here)
         */
        function calculateGlickoRating(rating, rd, results) {
            if (!results || results.length === 0) return { rating, rd };

            // compute sum terms
            let sum_g_s_minus_E = 0;
            let sum_g2_E1_E = 0;

            results.forEach(res => {
                const gg = g(res.opponentRD);
                const Est = E(rating, res.opponentRating, res.opponentRD);
                sum_g_s_minus_E += gg * (res.score - Est);
                sum_g2_E1_E += (gg * gg) * Est * (1 - Est);
            });

            // If sum_g2_E1_E is 0 we can't update (avoid division by zero)
            if (sum_g2_E1_E === 0) {
                return { rating, rd };
            }

            const d2 = 1 / (Math.pow(Q, 2) * sum_g2_E1_E);

            // denominator term for delta and RD update
            const preFactor = 1 / (Math.pow(rd, 2)) + 1 / d2;

            // rating change (mu' = mu + (q / preFactor) * sum(g*(s-E)))
            const delta = (Q / preFactor) * sum_g_s_minus_E;
            const newRating = Math.round(rating + delta * 1); // rating in same scale

            // new RD (decreases after match)
            const newRD = Math.sqrt(1 / preFactor);

            // enforce RD bounds (MIN_RD .. MAX_RD), because we use RD as a visibility/inactivity heuristic
            const boundedRD = Math.max(MIN_RD, Math.min(MAX_RD, newRD));

            return { rating: newRating, rd: boundedRD };
        }

        // ---------- Legacy Elo (kept for reference if needed) ----------
        function calculateNewElo(ratingA, ratingB, actualScoreA) {
            const expectedScoreA = 1 / (1 + Math.pow(10, (ratingB - ratingA) / 400));
            return Math.round(ratingA + K_FACTOR * (actualScoreA - expectedScoreA));
        }

        // ---------- Add Player ----------
        addPlayerForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const nameInput = document.getElementById('player-name').value.trim();
            const eloInput = parseInt(document.getElementById('initial-elo').value, 10);

            if (nameInput === '') return alert("Please enter a name.");

            const newPlayer = {
                id: Date.now().toString(),
                name: nameInput,
                elo: Number.isFinite(eloInput) ? eloInput : 1500,
                rd: MAX_RD,                  // start hidden until they play
                volatility: 0.06,            // placeholder (not used in this simplified Glicko)
                wins: 0,
                losses: 0,
                lastMatchDate: null         // null => never played
            };

            players.push(newPlayer);
            await saveData();
            updatePlayerRDs();
            updateUI();
            addPlayerForm.reset();
            document.getElementById('initial-elo').value = 1500;
        });

        // ---------- Log Match ----------
        logMatchForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const winnerId = winnerSelect.value;
            const loserId = loserSelect.value;

            if (!winnerId || !loserId) return alert("Please choose both players.");
            if (winnerId === loserId) return alert("A player cannot play against themselves!");

            const winner = players.find(p => String(p.id) === String(winnerId));
            const loser = players.find(p => String(p.id) === String(loserId));
            if (!winner || !loser) return alert("Player not found.");

            const oldWinnerElo = winner.elo;
            const oldLoserElo = loser.elo;

            // Prepare Glicko results (single-game rating period)
            const winnerResults = [{ opponentRating: loser.elo, opponentRD: loser.rd, score: 1 }];
            const loserResults  = [{ opponentRating: winner.elo, opponentRD: winner.rd, score: 0 }];

            const winnerUpdate = calculateGlickoRating(winner.elo, winner.rd, winnerResults);
            const loserUpdate  = calculateGlickoRating(loser.elo, loser.rd, loserResults);

            // Apply updates
            winner.elo = winnerUpdate.rating;
            winner.rd = winnerUpdate.rd;
            winner.wins = (winner.wins || 0) + 1;
            winner.lastMatchDate = new Date().toISOString();

            loser.elo = loserUpdate.rating;
            loser.rd = loserUpdate.rd;
            loser.losses = (loser.losses || 0) + 1;
            loser.lastMatchDate = new Date().toISOString();

            // Log action
            const newActionId = (Date.now() + Math.random()).toString();
            const action = {
                id: newActionId,
                type: 'match_result',
                winner: winner.name,
                loser: loser.name,
                winnerId: winnerId,
                loserId: loserId,
                oldWinnerElo: oldWinnerElo,
                oldLoserElo: oldLoserElo,
                newWinnerElo: winner.elo,
                newLoserElo: loser.elo,
                timestamp: new Date().toISOString()
            };
            actionLog.push(action);

            await saveData();
            updatePlayerRDs();
            updateUI();
            logMatchForm.reset();
        });

        // ---------- UI updates ----------
        function updateUI() {
            // Sort players by ELO descending
            players.sort((a,b) => b.elo - a.elo);

            // Render leaderboard (only players with RD < 100 are visible)
            leaderboardBody.innerHTML = '';
            const visiblePlayers = players.filter(p => (p.rd || MAX_RD) < MAX_RD);
            visiblePlayers.forEach((player, index) => {
                const tr = document.createElement('tr');
                const rankClass = index === 0 ? 'rank-1' : '';
                const rankDisplay = index === 0 ? 'üëë 1' : index + 1;
                const rd = player.rd ? Number(player.rd).toFixed(1) : MAX_RD.toFixed(1);
                tr.innerHTML = `
                    <td class="${rankClass}">${rankDisplay}</td>
                    <td class="${rankClass}">${player.name}</td>
                    <td class="${rankClass}">${player.elo} (¬±${rd})</td>
                    <td>${player.wins || 0} - ${player.losses || 0}</td>
                `;
                leaderboardBody.appendChild(tr);
            });

            // Populate dropdowns (alphabetical)
            winnerSelect.innerHTML = '<option value="">Select Winner...</option>';
            loserSelect.innerHTML = '<option value="">Select Loser...</option>';
            const sortedByName = [...players].sort((a,b) => a.name.localeCompare(b.name));
            sortedByName.forEach(player => {
                const optW = document.createElement('option');
                optW.value = player.id;
                optW.textContent = `${player.name} (${player.elo})`;
                winnerSelect.appendChild(optW);
                const optL = optW.cloneNode(true);
                loserSelect.appendChild(optL);
            });

            displayActionLog();
            displayPlayersList();
        }

        // ---------- Save data to Firestore ----------
        async function saveData() {
            try {
                // Save players
                const batchPlayers = db.batch ? db.batch() : null;
                // Use individual writes for maximum compatibility
                for (const player of players) {
                    await db.collection('players').doc(String(player.id)).set(player);
                }
                // Save action log
                for (const action of actionLog) {
                    await db.collection('actionLog').doc(String(action.id)).set(action);
                }
            } catch (err) {
                console.error('Error saving data:', err);
                alert('Error saving to database');
            }
        }

        // ---------- Display action log ----------
        function displayActionLog() {
            if (!actionLog || actionLog.length === 0) {
                actionLogContainer.innerHTML = '<p style="color: #888; text-align: center;">No actions recorded yet</p>';
                return;
            }

            actionLogContainer.innerHTML = '';
            const sortedLog = [...actionLog].sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp));
            sortedLog.forEach(action => {
                if (action.type !== 'match_result') return;
                const div = document.createElement('div');
                div.className = 'match-row';
                const winnerEloChange = (action.newWinnerElo || 0) - (action.oldWinnerElo || 0);
                const loserEloChange  = (action.newLoserElo  || 0) - (action.oldLoserElo  || 0);
                const actionDate = new Date(action.timestamp).toLocaleString();
                div.innerHTML = `
                    <div class="match-info">
                        <div><span style="color: #ff8c00; font-weight: bold;">‚öîÔ∏è Match:</span> <strong>${escapeHtml(action.winner)}</strong> defeated <strong>${escapeHtml(action.loser)}</strong></div>
                        <div style="font-size:0.85rem; color:#aaa; margin-top:4px;">
                            ${action.oldWinnerElo} ‚Üí ${action.newWinnerElo} <span style="color:#4fa34f;">(${winnerEloChange >= 0 ? '+'+winnerEloChange : winnerEloChange})</span>
                            &nbsp; vs &nbsp;
                            ${action.oldLoserElo} ‚Üí ${action.newLoserElo} <span style="color:#ff6464;">(${loserEloChange >= 0 ? '+'+loserEloChange : loserEloChange})</span>
                        </div>
                        <div style="font-size:0.75rem; color:#666;">${actionDate}</div>
                    </div>
                    <div class="action-buttons">
                        <button class="btn-small btn-delete" onclick="deleteAction('${action.id}')">Remove</button>
                    </div>
                `;
                actionLogContainer.appendChild(div);
            });
        }

        // ---------- Display players list ----------
        function displayPlayersList() {
            if (!players || players.length === 0) {
                playersListContainer.innerHTML = '<p style="color: #888; text-align:center;">No players yet</p>';
                return;
            }
            playersListContainer.innerHTML = '';
            players.forEach(player => {
                const el = document.createElement('div');
                el.className = 'match-row';
                const rd = player.rd ? Number(player.rd).toFixed(1) : MAX_RD.toFixed(1);
                const rdStatus = (player.rd >= MAX_RD) ? ' (Hidden from leaderboard)' : '';
                el.innerHTML = `
                    <div class="match-info">
                        <div><strong>${player.name}</strong> - ELO: ${player.elo} (¬±${rd})${rdStatus}</div>
                        <div style="font-size:0.85rem; color:#aaa;">${player.wins || 0}W - ${player.losses || 0}L</div>
                    </div>
                    <div class="action-buttons">
                        <button class="btn-small btn-delete" onclick="removePlayer('${player.id}')">Remove</button>
                    </div>
                `;
                playersListContainer.appendChild(el);
            });
        }

        // ---------- Recalculate from action log ----------
        function recalculatePlayerStats() {
            // reset players to starting defaults but keep IDs & names
            players.forEach(p => {
                p.wins = 0;
                p.losses = 0;
                // keep their initial starting elo if present, else 1500
                p.elo = typeof p.initialElo !== 'undefined' ? p.initialElo : 1500;
                p.rd = MAX_RD;
                p.volatility = 0.06;
                p.lastMatchDate = null;
            });

            // Ensure we have a map for id -> player
            const idMap = {};
            players.forEach(p => idMap[String(p.id)] = p);

            // Replay actions in chronological order
            const sortedActions = [...actionLog].sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
            for (const action of sortedActions) {
                if (action.type !== 'match_result') continue;
                const winner = idMap[String(action.winnerId)];
                const loser  = idMap[String(action.loserId)];
                if (!winner || !loser) continue;

                // compute updates
                const winnerResults = [{ opponentRating: loser.elo, opponentRD: loser.rd, score: 1 }];
                const loserResults  = [{ opponentRating: winner.elo, opponentRD: winner.rd, score: 0 }];

                const wu = calculateGlickoRating(winner.elo, winner.rd, winnerResults);
                const lu = calculateGlickoRating(loser.elo, loser.rd, loserResults);

                // store old & new into action for auditing
                action.oldWinnerElo = winner.elo;
                action.oldLoserElo  = loser.elo;

                winner.elo = wu.rating;
                winner.rd = wu.rd;
                winner.wins = (winner.wins || 0) + 1;
                winner.lastMatchDate = action.timestamp;

                loser.elo = lu.rating;
                loser.rd = lu.rd;
                loser.losses = (loser.losses || 0) + 1;
                loser.lastMatchDate = action.timestamp;

                action.newWinnerElo = winner.elo;
                action.newLoserElo  = loser.elo;
            }
        }

        // ---------- Delete action ----------
        async function deleteAction(actionId) {
            if (!confirm('Are you sure you want to remove this match?')) return;
            const idx = actionLog.findIndex(a => String(a.id) === String(actionId));
            if (idx === -1) return;
            actionLog.splice(idx, 1);
            try {
                await db.collection('actionLog').doc(String(actionId)).delete();
            } catch (err) {
                console.warn('Delete action from Firestore failed (maybe missing):', err);
            }
            recalculatePlayerStats();
            await saveData();
            updatePlayerRDs();
            updateUI();
        }

        // ---------- Remove player ----------
        async function removePlayer(playerId) {
            if (!confirm('Are you sure you want to remove this player? All their matches will be deleted.')) return;
            // remove actions involving this player
            actionLog = actionLog.filter(a => !(String(a.winnerId) === String(playerId) || String(a.loserId) === String(playerId)));
            // remove player
            const pidx = players.findIndex(p => String(p.id) === String(playerId));
            if (pidx !== -1) {
                try {
                    await db.collection('players').doc(String(playerId)).delete();
                } catch (err) {
                    console.warn('Delete player from Firestore failed (maybe missing):', err);
                }
                players.splice(pidx, 1);
            }
            recalculatePlayerStats();
            await saveData();
            updatePlayerRDs();
            updateUI();
        }

        // ---------- Utilities ----------
        function escapeHtml(s) {
            return String(s).replace(/[&<>"'`=\/]/g, function (c) {
                return {
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;',
                    "'": '&#39;', '/': '&#x2F;', '`': '&#x60;', '=': '&#x3D;'
                }[c];
            });
        }

        // Run initialization
        init();
    </script>
</body>
</html>